9:42 PM

第八章、模版方法
  - 模板(一个方法)方法定义了一个算法的步骤，并允许子类为一个或多个步骤（模板里是抽象的）提供实现。
	- 模板方法模式在一个方法中定义 一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
	- 钩子是一种被声明在抽象类中的方法，是可选的。钩子的存在可以让子类有能力对算法的不同点进行挂钩，要不要挂钩由子类决定。抽象子类可以实现成钩子。
	- 好莱坞原则：别调用我们，我们会调用你。好莱坞原则dependence injection，当高层组建以来底层组建，而底层组建又依赖高层组件，而高层组件又依赖边侧组件这种情况。使用好莱坞组件可以保证高层组件可以控制何时以及如何让底层组件参与其中。为了防止子类修改模板方法中的算法，可以将模板方法声明为 final。策略模式和模板方法模式都封装算法，一个用组合，一个用继承方法。工厂方法是一种特殊的模板方法。
	- java里的compareTo是个例子
	
第九章 迭代器与组合模式
- 迭代器模式iterator，需要知道的第一件事情就是，它依赖一个名为迭代器的接口，其中有两个重要方法 hasNext()、next()。
- collection: all kinds of data structure, eg, aggrefate
- 迭代器让我们能够便利聚合中的每个元素，而不会强迫聚合必须提供方法，让我们在它的元素中游走，我们可以在聚合的外面实现迭代器，换句话说，我们封装了遍历。
- 对于迭代器中 remove 方法，实现的过程中，我们需要根据自己的数据结构，如果是数组那么就需要修改下标。这样我们可以对不同对象实现相同接口，通过“针对接口编程，而不是针对实现编程”，减少迭代和具体类之间的依赖
- 迭代器模式提供了一种方法顺序访问一个聚合对象中的各个对象，而又不暴露其内部的表示。
- 迭代器模式让我们能游走于聚合内的每一个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合上，这样集合了聚合的接口和实现，也让责任各得其所。
- 迭代器模式给你提供了一种方法，可以顺序访问一个聚合对象中的元素，而又不用知道内部是如何表示的。
- signle repsonsibility 单一职责原则：一个类应该只有一个引起变化的原因。
- 类的每个责任都有改变的潜在区域，超过一个责任，意味着超过一个改变的区域，这个原则告诉我们，尽量让每个类保持单一职责。
- 组合模式：允许你讲对象组合成树形的结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
- 组合模式让我们能用树形方式创建对象的结构
- 使用组合结构，我们能把相同的操作应用在组合个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。
  
  
第十章 状态模式
	• 状态模式允许对象内部状态发生改变时改变它的行为，对象看起来好像修改了它的类
	• 策略模式是除了继承之外的一种弹性替代方案。
	• 如果你继承了一个类，那么你将被这个类行为给困住，但是如果使用策略模式可以灵活替换对象来改变行为。
	• 状态模式可以想成是不用在 Context 中放置许多条件判断的替代方法，通过将行为包装进状态对象中，你可以通过在 Context 内简单地改变状态对象来改变 Context 的行为。状态类可以被多个 Context 共享。
	• 和状态机不同，状态模式使用类表示状态。
	• 状态模式和策略模式有相同的类图，但是他们的意图不同。
	• 使用状态模式通常会导致类的数量会大幅增加。
	
  
第十一章 控制对象访问
	• 代理模式为另一个对象提供一个替身或者占位符以控制着个对象的访问。
	• 虚拟代理控制访问实例化大的对象。
	• 保护代理基于调用者控制对对象方法的访问。
	• 代理模式有多种变种，例如有缓存代理、同步代理、防火墙代理和写入时复制代理。
	• 代理结构和装饰着结构类似，但是目的不同。
	• 装饰者模式为对象加上行为，而代理则是控制访问
	• Java 内置但代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器。
  
第十二章 复合模式
	• MVC 是复合模式，结合了观察者模式、策略模式和组合模式。model, view, controller
	• 模型使用观察者模式，以便观察者更新，同时保持两者之间解耦。
	• 控制器是试图的策略，试图可以使用不同的控制器实现，得到不同的行为。
	• 试图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，类似面板、框架和按钮。
	• 适配器模式用来将新的模型是配成一游的视图和控制器。
  Angular, AngularJS - MVVM, using mode, view, whatever
  
第十三章 与模式相处
	• 模式是在某种情境下，针对某问题的某种解决方案。
	• 情景是应用某个模式的情况，这应该是会不断出现的情况。
	• 问题是你想在某种情境下达到的目标，但也可以是某情景下的约束。
	• 解决方案就是你所追求，一个通用的设计，用来解决约束、达到目标。
	• 装饰者模式：包装一个对象，以提供新的行为。
	• 状态模式：封装了基于状态的行为，并使用委托在行为之前切换。
	• 迭代器模式：在对象的集合之中游走，而不暴露集合的实现。
	• 外观模式：简化一群类的接口
	• 策略模式：封装可以呼唤的行为，并使用委托来决定要使用哪一个。
	• 代理模式：包装对象，以控制次对象的访问。
	• 工厂方法：有子类决定要创建的具体类是哪一个。
	• 适配器模式：封装对象，并提供不同的接口。
	• 观察者模式：让对象能够在状态改变时被通知。
	• 模板方法：由子类决定如何实现一个算法中的步骤。
	• 组合：客户用一致的方式处理对象集合和单个对象。
	• 单例模式：确保只有一个对象被创建。
	• 抽象工厂：允许客户创建对象的家族，而无需指定他们的具体类。
命令模式：封装请求成为对象。
